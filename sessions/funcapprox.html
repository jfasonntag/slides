<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Florian Oswald" />
  <title>Computational Economics: Function Approximation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; background-color: #dddddd; }
td.sourceCode { padding-left: 5px; }
code > span.kw { font-weight: bold; } /* Keyword */
code > span.dt { color: #800000; } /* DataType */
code > span.dv { color: #0000ff; } /* DecVal */
code > span.bn { color: #0000ff; } /* BaseN */
code > span.fl { color: #800080; } /* Float */
code > span.ch { color: #ff00ff; } /* Char */
code > span.st { color: #dd0000; } /* String */
code > span.co { color: #808080; font-style: italic; } /* Comment */
code > span.al { color: #00ff00; font-weight: bold; } /* Alert */
code > span.fu { color: #000080; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #ff0000; font-weight: bold; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #ff00ff; } /* SpecialChar */
code > span.vs { color: #dd0000; } /* VerbatimString */
code > span.ss { color: #dd0000; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { } /* ControlFlow */
code > span.op { } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { font-weight: bold; } /* Preprocessor */
code > span.at { } /* Attribute */
code > span.do { color: #808080; font-style: italic; } /* Documentation */
code > span.an { color: #808080; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #808080; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #808080; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Computational Economics: Function Approximation</h1>
  <p class="author">
Florian Oswald
  </p>
  <p class="date">Sciences Po, Spring 2016</p>
</div>
<div id="outline" class="slide section level1">
<h1>Outline</h1>
<ol style="list-style-type: decimal">
<li>Overview of Approximation Methods
<ol style="list-style-type: decimal">
<li>Interpolation</li>
<li>Regression</li>
</ol></li>
<li>Polynomial Interpolation</li>
<li>Spline Interpolation</li>
<li>Multidimensional Approximation</li>
</ol>
</div>
<div id="approximation-methods" class="slide section level1">
<h1>Approximation Methods</h1>
<ul>
<li>Confronted with a non-analytic function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> (i.e. something not like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">log(x)</annotation></semantics></math>), we need a way to numerically represent <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> in a computer.
<ul>
<li>If your problem is to compute a value function in a dynamic problem, you don't have an analytic representation of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>.</li>
<li>If you need to compute an equilibrium distribution for your model, you probably can't tell it's from one parametric family or another.</li>
</ul></li>
<li>Approximations use <em>data</em> of some kind which informs us about <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>. Most commonly, we know the function values <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(x_i)</annotation></semantics></math> at a corresponding finite set of points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>x</mi><mi>i</mi></msub><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup></mrow><annotation encoding="application/x-tex">X = \{x_i\}_{i=1}^N</annotation></semantics></math>.</li>
<li>The task of approximation is to take that data and tell us what the function value is at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>y</mi><mo>∉</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f(y),y\not \in X</annotation></semantics></math>.</li>
<li>To an economist this should sound very familiar: take a dataset, learn it's structure, and make predictions.</li>
<li>The only difference is that we can do much better here, because we have more degree's of freedom (we can choose our <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>β</mi><mi>X</mi><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">Y=\beta X + \epsilon</annotation></semantics></math>)</li>
</ul>
</div>
<div id="some-classification" class="slide section level1">
<h1>Some Classification</h1>
<ul>
<li>Local Approximations: approximate function and it's derivative <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>,</mo><mi>f</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">f,f&#39;</annotation></semantics></math> at a <em>single</em> point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>0</mn></msub><annotation encoding="application/x-tex">x_0</annotation></semantics></math>. Taylor Series: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><mi>f</mi><mi>′</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mfrac><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><mn>2</mn></mfrac><mi>f</mi><mi>″</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>…</mi><mo>+</mo><mfrac><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub><msup><mo stretchy="false" form="postfix">)</mo><mi>n</mi></msup></mrow><mrow><mi>n</mi><mi>!</mi></mrow></mfrac><msup><mi>f</mi><mi>n</mi></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> f(x) = f(x_0) + (x-x_0)f&#39;(x_0) + \frac{(x-x_0)^2}{2}f&#39;&#39;(x_0) + \dots + \frac{(x-x_0)^n}{n!}f^{n}(x_0) </annotation></semantics></math></li>
<li>Interpolation or <em>Colocation</em>: find a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>f</mi><mo accent="true">^</mo></mover><annotation encoding="application/x-tex">\hat{f}</annotation></semantics></math> that is a good fit to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, and require that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>f</mi><mo accent="true">^</mo></mover><annotation encoding="application/x-tex">\hat{f}</annotation></semantics></math> <em>passes through</em> the points. If we think of there being a <em>residual</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϵ</mi><mi>i</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mover><mi>f</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\epsilon_i = f(x_i) - \hat{f}(x_i)</annotation></semantics></math> at each grid point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>, this methods succeeds in setting <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϵ</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn><mo>,</mo><mo>∀</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\epsilon_i=0,\forall i</annotation></semantics></math>.</li>
<li>Regression: Minimize some notion of distance (squared) between <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>f</mi><mo accent="true">^</mo></mover><annotation encoding="application/x-tex">\hat{f}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, without the requirement of pass through.</li>
</ul>
</div>
<div id="doing-interpolation-in-julia" class="slide section level1">
<h1>Doing Interpolation in Julia</h1>
<ul>
<li>In practice, you will make heavy use of high-quality interpolation packages in julia.</li>
<li>List in the end.</li>
<li>Nevertheless, function approximation is <em>extremely</em> problem-specific, so sometimes a certain approach does not work for your problem.</li>
<li>This is why we will go through the mechanics of some common methods.</li>
<li>I would like you to know where to start drilling if you need to go and hack somebody elses code.</li>
</ul>
</div>
<div id="interpolation-basics" class="slide section level1">
<h1>Interpolation Basics</h1>
<ul>
<li>Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> be a smooth function mapping <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>d</mi></msup><mo accent="false">↦</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbb{R}^d \mapsto \mathbb{R}</annotation></semantics></math>, and define <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="prefix">(</mo><mo>⋅</mo><mo>;</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\hat{f}(\cdot;c)</annotation></semantics></math> to be our parametric approximation function. We generically define this as <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>;</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>J</mi></munderover><msub><mi>c</mi><mi>j</mi></msub><msub><mi>ϕ</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">  \hat{f}(x;c) = \sum_{j=1}^J c_j \phi_j(x) </annotation></semantics></math> where
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>j</mi></msub><mo>:</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>d</mi></msup><mo accent="false">↦</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">\phi_j : \mathbb{R}^d \mapsto \mathbb{R}</annotation></semantics></math> is called a <strong>basis function</strong>,</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>,</mo><msub><mi>c</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>c</mi><mi>J</mi></msub></mrow></mrow><annotation encoding="application/x-tex">c={c_1,c_2,\dots,c_J}</annotation></semantics></math> is a coefficient vector</li>
</ul></li>
<li>The integer <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math> is the <em>order</em> of the interpolation.</li>
<li>Our problem is to choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>ϕ</mi><mi>i</mi></msub><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\phi_i,c)</annotation></semantics></math> in some way.</li>
<li>We will construct a <em>grid</em> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>≥</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">M\geq J</annotation></semantics></math> points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">{x_1,\dots,x_M}</annotation></semantics></math> within the domain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>d</mi></msup><annotation encoding="application/x-tex">\mathbb{R}^d</annotation></semantics></math>, and we will denote the <em>residuals</em> at each grid point by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>=</mo><mrow><msub><mi>ϵ</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>ϵ</mi><mi>M</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\epsilon = {\epsilon_1,\dots,\epsilon_M}</annotation></semantics></math>: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>ϵ</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>ϵ</mi><mi>M</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>M</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>−</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>ϕ</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msub><mi>ϕ</mi><mi>J</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>ϕ</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>M</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msub><mi>ϕ</mi><mi>J</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>M</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>⋅</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>c</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>c</mi><mi>J</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex"> \left[\begin{array}{c}
    \epsilon_1 \\
     \vdots \\
    \epsilon_M \\ \end{array} \right]  = \left[\begin{array}{c} f(x_1) \\ \vdots \\ f(x_M)  \end{array} \right] - \left[\begin{array}{ccc} 
    \phi_1(x_1) &amp; \dots &amp; \phi_J(x_1) \\   
    \vdots      &amp; \ddots &amp; \vdots \\   
    \phi_1(x_M) &amp; \dots &amp; \phi_J(x_M)    
    \end{array} \right]  \cdot 
    \left[\begin{array}{c} c_1 \\ \vdots \\ c_J  \end{array} \right]
    </annotation></semantics></math></li>
<li><em>Interpolation</em> or colocation occurs when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">J=M</annotation></semantics></math>, i.e. we have a square matrix of basis functions, and can exactly solve this.</li>
<li>We basically need to solve the system <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>c</mi><mi>j</mi></msub><msub><mi>ϕ</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo>∀</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mtd></mtr><mtr><mtd columnalign="right"><mstyle mathvariant="bold"><mi>𝚽</mi><mi>𝐜</mi></mstyle></mtd><mtd columnalign="left"><mo>=</mo><mstyle mathvariant="bold"><mi>𝐲</mi></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{align} \sum_{j=1}^n c_j \phi_j(x_i) &amp;= f(x_i),\forall i=1,2,\dots,n \\
                  \mathbf{\Phi c}&amp;= \mathbf{y}
    \end{align}
 </annotation></semantics></math> where the second line uses vector notation, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐲</mi></mstyle><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math> has all values of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>.</li>
<li>Solution: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>𝐜</mi></mstyle><mo>=</mo><msup><mstyle mathvariant="bold"><mi>𝚽</mi></mstyle><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>y</mi></mrow><annotation encoding="application/x-tex">\mathbf{c}= \mathbf{\Phi}^{-1}y</annotation></semantics></math>.</li>
</ul>
</div>
<div id="regression-basics" class="slide section level1">
<h1>Regression Basics</h1>
<ul>
<li>Clearly, on the previous slide we required that there are as many interpolation nodes as there are basis functions - we had <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math> equations for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> unknowns, so there exists a unique solution for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>.</li>
<li>We needed to <em>invert</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝚽</mi></mstyle><annotation encoding="application/x-tex">\mathbf{\Phi}</annotation></semantics></math>.</li>
<li>If we have more, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>&gt;</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">M&gt;J</annotation></semantics></math> say, interpolation nodes than basis functions, we cannot do that. Instead we can define a loss function, and minimize it.</li>
<li>In the case of squared loss, of course, this leads to the least squares solution: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><msub><mi>e</mi><mi>i</mi></msub></mtd><mtd columnalign="left"><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>c</mi><mi>j</mi></msub><msub><mi>ϕ</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"><munder><mo>min</mo><mi>c</mi></munder><msubsup><mi>e</mi><mi>i</mi><mn>2</mn></msubsup></mtd><mtd columnalign="left"><mo accent="false">⟹</mo></mtd></mtr><mtr><mtd columnalign="right"><mi>c</mi></mtd><mtd columnalign="left"><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>Φ</mi><mi>′</mi><mi>Φ</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>Φ</mi><mi>′</mi><mi>y</mi></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{align} e_i &amp;= f(x_i) - \sum_{j=1}^n c_j \phi_j(x_i) \\
        \min_c e_i^2 &amp; \implies \\
        c            &amp;= (\Phi&#39;\Phi)^{-1} \Phi&#39;y
    \end{align}
 </annotation></semantics></math></li>
</ul>
</div>
<div id="spectral-and-finite-element-methods" class="slide section level1">
<h1>Spectral and Finite Element Methods</h1>
<ul>
<li>Spectral Methods are such that the basis functions are non-zero over the entire domain of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>.
<ul>
<li>Polynomial interpolation</li>
<li>Chebychev interpolation</li>
</ul></li>
<li>Finite Element methods are such that basis functions are non-zero only on a subset of the domain.
<ul>
<li>Splines
<ul>
<li>Linear splines, i.e. splines of degree 1, a.k.a. <em>linear approximation</em></li>
<li>Higher order splines, mainly the <em>cubic spline</em>.</li>
</ul></li>
</ul></li>
</ul>
<div class="incremental">
<h3 id="what-makes-a-good-approximation">What makes a good Approximation?</h3>
<ul>
<li>Should be arbitrarily accurate as we increase <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math> Should be efficiently (fast) computable. If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math> were differentiable, we could easily get e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">^</mo></mover><mi>′</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>J</mi></msubsup><msub><mi>c</mi><mi>j</mi></msub><msub><mi>ϕ</mi><mi>j</mi></msub><mi>′</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\hat{f}&#39;(x) = \sum_{j=1}^J c_j \phi_j&#39;(x_i)</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> Should be efficiently (fast) computable.</li>
</ul>
</div>
</div>
<div id="polynomial-interpolation" class="slide section level1">
<h1>Polynomial Interpolation</h1>
<ul>
<li>For any continuous real-valued function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> on interval <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math>, and an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\epsilon&gt;0</annotation></semantics></math>, there is a polynomial <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>, such that <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">|</mo><mo stretchy="false" form="prefix">|</mo><mi>f</mi><mo>−</mo><mi>p</mi><mo stretchy="false" form="prefix">|</mo><msub><mo stretchy="false" form="prefix">|</mo><mi>∞</mi></msub><mo>≡</mo><munder><mo>sup</mo><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo></mrow></munder><mo stretchy="false" form="prefix">|</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mi>p</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mo>&lt;</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex"> || f - p ||_\infty \equiv \sup_{x\in[a,b]} |f(x)-p(x)| &lt; \epsilon </annotation></semantics></math></li>
<li>However, the choice of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> is critical. <em>Orthogonal Polynomials</em> have been shown to perform very well.</li>
</ul>
<blockquote>
<p><span style="color:red">Definition - Orthogonal Polynomials</span>: an orthogonal polynomial sequence is a family of polynomials such that any two different polynomials in the sequence are orthogonal to each other under some inner product.</p>
</blockquote>
<ul>
<li>There are many families that satisfy this. See <span class="citation">(Kenneth L. Judd 1998)</span> table 6.3 for an overview.</li>
<li>We will now look at a widely used family, the Chebyshev polynomial.</li>
</ul>
</div>
<div id="chebyshev-nodes" class="slide section level1">
<h1>Chebyshev Nodes</h1>
<ul>
<li><em>Chebyshev Nodes</em> are defined in the interval <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[-1,1]</annotation></semantics></math> as <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mo>cos</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>2</mn><mi>k</mi><mo>−</mo><mn>1</mn></mrow><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mi>π</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex"> x_i = \cos\left(\frac{2k-1}{2n} \pi\right), k=1,\dots,n </annotation></semantics></math></li>
<li>Which maps to general interval <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math> as <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>cos</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>2</mn><mi>k</mi><mo>−</mo><mn>1</mn></mrow><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mi>π</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex"> x_i = \frac{1}{2} (a+b) + \frac{1}{2} (b-a) \cos\left(\frac{2k-1}{2n} \pi\right) , k=1,\dots,n </annotation></semantics></math></li>
<li>Chebyshev nodes are <strong>not</strong> evenly spaced: there are more points towards the boundaries.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia">using PyPlot
using FastGaussQuadrature: gausschebyshev
nodes = gausschebyshev(<span class="fl">11</span>)  <span class="co"># generate 11 Chebyshev Nodes</span>
fig = figure(figsize=(<span class="fl">10</span>,<span class="fl">4</span>))
title(L<span class="st">&quot;Chebyshev Nodes $x \in [-1,1]$&quot;</span>)
ax = axes()
ax[:plot](nodes[<span class="fl">1</span>], ones(<span class="fl">11</span>), <span class="st">&quot;+r&quot;</span>)
ax[:yaxis][:set_visible](false)
fig[:canvas][:draw]()  <span class="co"># update figure</span></code></pre></div>
</div>
<div id="chebyshev-nodes-1" class="slide section level1">
<h1>Chebyshev Nodes</h1>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">
<img src="figs/cheby-nodes.png" alt="Chebyshev Nodes" />
</div>
</div>
<div id="what-polynomial-to-use-what-form-for-phi" class="slide section level1">
<h1>What Polynomial to use? What form for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math>?</h1>
<ul>
<li>In principle the <em>monomial basis</em> could be used. It is just the power functions of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi><mn>2</mn></msup><mo>,</mo><msup><mi>x</mi><mn>3</mn></msup><mo>,</mo><mi>…</mi></mrow><annotation encoding="application/x-tex">1,x,x^2,x^3,\dots</annotation></semantics></math></li>
<li>Stacking this up for each evaluation node (Chebyshev, or any other), gives the <em>Vandermonde Matrix</em>: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><msub><mi>x</mi><mn>1</mn></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msubsup><mi>x</mi><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>x</mi><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><msub><mi>x</mi><mn>2</mn></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msubsup><mi>x</mi><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>x</mi><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><msub><mi>x</mi><mi>m</mi></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msubsup><mi>x</mi><mi>m</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>x</mi><mi>m</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex"> V = \left[\begin{matrix} 
        1 &amp; x_1 &amp; \dots &amp; x_1^{n-2} &amp; x_1^{n-1} \\ 
        1 &amp; x_2 &amp; \dots &amp; x_2^{n-2} &amp; x_2^{n-1} \\ 
        \vdots &amp; \vdots &amp; \ddots &amp;  &amp; \vdots \\ 
        1 &amp; x_m &amp; \dots &amp; x_m^{n-2} &amp; x_m^{n-1} 
        \end{matrix} \right]
        </annotation></semantics></math> for the case with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> evaluation nodes for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> basis functions for each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>i</mi></msub><annotation encoding="application/x-tex">x_i</annotation></semantics></math>.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math> is ill-conditioned and thus a bad choice.</li>
<li>A much better polynomial basis is - surprise, surprise - the <em>Chebyshev Polynomial basis</em>.</li>
</ul>
</div>
<div id="evaluating-the-chebyshev-polynomial-and-basis-function" class="slide section level1">
<h1>Evaluating the Chebyshev Polynomial and Basis Function</h1>
<ul>
<li>As before, this Basis is defined in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[-1,1]</annotation></semantics></math>, so for general <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x\in[a,b]</annotation></semantics></math> we normalize <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> to <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub><mo>=</mo><mn>2</mn><mfrac><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>a</mi></mrow><mrow><mi>b</mi><mo>−</mo><mi>a</mi></mrow></mfrac><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> z_i = 2\frac{x_i-a}{b-a} -1 </annotation></semantics></math></li>
<li>There are several ways to obtain the value of the order <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math> Chebyshev polynomial at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>, e.g. to get <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=0}^n a_i T_i(z)</annotation></semantics></math>.
<ol style="list-style-type: decimal">
<li>use definition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><mo>arccos</mo><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mi>j</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">T_j(z) = \cos(\arccos(z)j)</annotation></semantics></math>. Or</li>
<li>Recursively we have that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>T</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi_j(x) = T_{j-1}(z)</annotation></semantics></math>, and <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><msub><mi>T</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo></mtd><mtd columnalign="left"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="right"><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo></mtd><mtd columnalign="left"><mi>z</mi></mtd></mtr><mtr><mtd columnalign="right"><msub><mi>T</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo></mtd><mtd columnalign="left"><mn>2</mn><mi>z</mi><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><msub><mi>T</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{align}
    T_0(z) =&amp; 1 \\
    T_1(z) =&amp; z \\
    T_{i+1}(z) =&amp; 2zT_i(z) - T_{i-1}(z),i=1,\dots,n
    \end{align}
    </annotation></semantics></math></li>
</ol></li>
</ul>
<div class="incremental">
<h3 id="constructing-phi-as-t-evaluated-at-the-chebyshev-nodes">Constructing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math> as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> evaluated <em>at</em> the Chebyshev Nodes</h3>
<ul>
<li>Combining Chebyshev nodes evaluated at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> to construct <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math> is a particularly good idea.</li>
<li>Doing so, we obtain an interpolation matrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math> with typical element <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo>cos</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>0.5</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mi>π</mi></mrow><mi>n</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \phi_{ij} = \cos\left( \frac{(n-i+0.5)(j-1)\pi}{n}\right)  </annotation></semantics></math></li>
<li>And we obtain that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math> is indeed orthogonal <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Φ</mi><mi>T</mi></msup><mi>Φ</mi><mo>=</mo><mtext mathvariant="normal">diag</mtext><mo stretchy="false" form="prefix">{</mo><mi>n</mi><mo>,</mo><mi>n</mi><mi>/</mi><mn>2</mn><mo>,</mo><mi>n</mi><mi>/</mi><mn>2</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi><mi>/</mi><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex"> \Phi^T \Phi = \text{diag}\{n,n/2,n/2,\dots,n/2\}  </annotation></semantics></math></li>
</ul>
</div>
</div>
<div id="chebyshev-interpolation-proceedure" class="slide section level1">
<h1>(Chebyshev) Interpolation Proceedure</h1>
<ul>
<li>Let's summarize this proceedure.</li>
<li>Instead of Chebyshev polynomials we could be using any other suitable family of polynomials.</li>
<li>To obtain a Polynomial interpolant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>f</mi><mo accent="true">^</mo></mover><annotation encoding="application/x-tex">\hat{f}</annotation></semantics></math>, we need:
<ol style="list-style-type: decimal">
<li>a function to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> interpolate. We need to be able to get the function values somehow.</li>
<li>A set of (Chebyshev) interpolation nodes at which to compute <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math></li>
<li>An interpolation matrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math> that corresponds to the nodes we have chosen.</li>
<li>A resulting coefficient vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math></li>
</ol></li>
<li>To obtain the value of the interpolation at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">x&#39;</annotation></semantics></math> off our grid, we also need a way to evaluate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Φ</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>′</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Phi(x&#39;)</annotation></semantics></math> .
<ol style="list-style-type: decimal">
<li>Evaluate the Basis function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math> at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">x&#39;</annotation></semantics></math></li>
<li>obtain new values as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>Φ</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">y = \Phi c</annotation></semantics></math>.</li>
</ol></li>
</ul>
</div>
<div id="polynomial-interpolation-with-julia-approxfun.jl" class="slide section level1">
<h1>Polynomial Interpolation with <code>Julia</code>: <code>ApproxFun.jl</code></h1>
<ul>
<li><a href="https://github.com/ApproxFun/ApproxFun.jl"><code>ApproxFun.jl</code></a> is a Julia package based on the Matlab package <a href="http://www.chebfun.org"><code>chebfun</code></a>. It is quite amazing.</li>
<li>More than just <em>function approximation</em>. This is a toolbox to actually <em>work</em> with functions.</li>
<li>given 2 functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>,</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f,g</annotation></semantics></math>, we can do algebra with them, i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">h(x) = f(x) + g(x)^2</annotation></semantics></math></li>
<li>We can differentiate and integrate</li>
<li>Solve ODE's and PDE's</li>
<li>represent period functions</li>
<li>Head over to the website and look at the readme.</li>
</ul>
</div>
<div id="polynomial-interpolation-with-julia-approxfun.jl-1" class="slide section level1">
<h1>Polynomial Interpolation with <code>Julia</code>: <code>ApproxFun.jl</code></h1>
<ul>
<li>This even works with discontinuities:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia">using ApproxFun
ff = x-&gt;sign(x-<span class="fl">0.1</span>)/<span class="fl">2</span> + cos(<span class="fl">4</span>*x);  <span class="co"># sign introduces a jump at 0.1</span>
x  = Fun(identity)  <span class="co"># set up a function space</span>
space(x)
f  = ff(x)  <span class="co"># define ff on that space</span>
ApproxFun.plot(f)   <span class="co"># plot</span>

<span class="co"># whats the first deriv at 0.785?</span>
f&#39;(<span class="fl">0.785</span>)
<span class="co"># integral of f?</span>
g = cumsum(f)
g = g + f(-<span class="fl">1</span>)
integral = norm(f-g)</code></pre></div>
</div>
<div id="polynomial-interpolation-with-julia-approxfun.jl-2" class="slide section level1">
<h1>Polynomial Interpolation with <code>Julia</code>: <code>ApproxFun.jl</code></h1>
<ul>
<li>The main purpose of this package is to manipulate analytic functions, i.e. function with an algebraic representation.</li>
<li>There is the possibility to supply a set of data points and fit a polynomial:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia">S=Chebyshev([-<span class="fl">1</span>,<span class="fl">1</span>])
x=points(S,<span class="fl">20</span>)  <span class="co"># Get 20 points from that space</span>
v=cos(cos(<span class="fl">4</span>*x))
f=Fun(ApproxFun.transform(S,v),S)
setplotter(<span class="st">&quot;PyPlot&quot;</span>)
figure()
subplot(<span class="fl">121</span>) <span class="co">#create first axis of 1x2 plot array</span>
ApproxFun.plot(f)
title(L<span class="st">&quot;$f(x)=\cos(4x)$&quot;</span>)
<span class="co"># what about some random data?</span>
v2=rand(<span class="fl">20</span>)
f2=Fun(ApproxFun.transform(S,v2),S)
subplot(<span class="fl">122</span>) <span class="co">#create second axis of 1x2 plot array</span>
title(<span class="st">&quot;x = rand(20)&quot;</span>)
ApproxFun.plot(f2,linewidth=<span class="fl">1.5</span>)
ApproxFun.plot(x,v2,marker=<span class="st">&quot;o&quot;</span>,color=<span class="st">&quot;red&quot;</span>)</code></pre></div>
<ul>
<li>Check out more examples with <a href="https://github.com/ApproxFun/ApproxFun.jl/issues/275">my conversation with one of the package authors</a></li>
</ul>
</div>
<div id="approxfun.jl-fitting-some-random-data" class="slide section level1">
<h1><code>ApproxFun.jl</code> fitting some (random) data</h1>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">
<img src="figs/approxFun-data.png" alt="ApproxFun.jl data fitting" />
</div>
</div>
<div id="splines-piecewise-polynomial-approximation" class="slide section level1">
<h1>Splines: Piecewise Polynomial Approximation</h1>
<ul>
<li>Splines are a finite element method, i.e. there are regions of the function domain where some basis functions are zero.</li>
<li>As such, they provide a very flexible framework for approximation instead of high-order polynomials.
<ul>
<li>Keep in mind that Polynomials basis functions are non-zero on the entire domain. Remember the Vandermonde matrix.</li>
</ul></li>
<li>They bring some element of local approximation back into our framework. What happens at one end of the domain to the function is not important to what happens at the other end.</li>
<li>Looking back at the previous plot of random data: we are searching for <strong>one</strong> polynomial to fit <strong>all</strong> those wiggles. A spline will allow us to design <strong>different</strong> polynomials in different parts of the domain.</li>
</ul>
<div class="incremental">
<h2 id="splines-basic-setup">Splines: Basic Setup</h2>
<ul>
<li>The fundamental building block is the <em>knot vector</em>, or the <em>breakpoints vector</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle><annotation encoding="application/x-tex">\mathbf{z}</annotation></semantics></math> of length <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>. An element of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle><annotation encoding="application/x-tex">\mathbf{z}</annotation></semantics></math> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>z</mi><mi>i</mi></msub><annotation encoding="application/x-tex">z_i</annotation></semantics></math>.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle><annotation encoding="application/x-tex">\mathbf{z}</annotation></semantics></math> is ordered in ascending order.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle><annotation encoding="application/x-tex">\mathbf{z}</annotation></semantics></math> spans the domain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math> of our function, and we have that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><msub><mi>z</mi><mn>1</mn></msub><mo>,</mo><mi>b</mi><mo>=</mo><msub><mi>z</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">a=z_1,b=z_p</annotation></semantics></math></li>
<li>A spline is of <em>order k</em> if the polynomial segments are k-th order polynomials.</li>
<li>Literature: <span class="citation">(De Boor 1978)</span> is the definitive reference for splines.</li>
</ul>
</div>
</div>
<div id="splines-characterization" class="slide section level1">
<h1>Splines: Characterization</h1>
<ul>
<li>Given <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> knots, there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p-1</annotation></semantics></math> polynomial segments of order <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>, each characterized by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math> coefficients, i.e. a total of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(p-1)(k+1)</annotation></semantics></math> parameters.</li>
<li>However, we also require the spline to be continuous and differentiable of degree <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math> at the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">p-2</annotation></semantics></math> interior breakpoints.</li>
<li>Imposing that uses up an additional <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo>−</mo><mn>2</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">k(p-2)</annotation></semantics></math> conditions.</li>
<li>We are left with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo>−</mo><mn>2</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>p</mi><mo>+</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n = (p-1)(k+1) - k(p-2) = p+k-1</annotation></semantics></math> free parameters.</li>
<li>A Spline of order <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> knots can thus be written as a linear combination of it's <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>+</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n = p+k-1</annotation></semantics></math> basis functions.</li>
</ul>
</div>
<div id="splines-show-some-basis-functions" class="slide section level1">
<h1>Splines: Show some Basis Functions</h1>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia">using ApproXD   
<span class="co"># Pkg.clone(&quot;https://github.com/floswald/ApproXD.jl&quot;)</span>
using PyPlot
bs = BSpline(<span class="fl">7</span>,<span class="fl">3</span>,<span class="fl">0</span>,<span class="fl">1</span>) <span class="co">#7 knots, degree 3 in [0,1]</span>
<span class="co"># how many basis functions? (go back 1 slide.)</span>
<span class="co"># getNumCoefs(bs)</span>
B = full(getBasis(collect(linspace(<span class="fl">0</span>,<span class="fl">1.0</span>,<span class="fl">500</span>)),bs))
<span class="co"># setup the plot</span>
fig,axes = subplots(<span class="fl">3</span>,<span class="fl">3</span>,figsize=(<span class="fl">10</span>,<span class="fl">5</span>))
<span class="kw">for</span> i <span class="kw">in</span> <span class="fl">1</span>:<span class="fl">3</span>
    <span class="kw">for</span> j <span class="kw">in</span> <span class="fl">1</span>:<span class="fl">3</span>
        ax = axes[j,i]
        count = i+(j-<span class="fl">1</span>)*<span class="fl">3</span>
        ax[:plot](B[:,count])
        ax[:grid]()
        ax[:set_title](<span class="st">&quot;Basis $(count-1)&quot;</span>)
        ax[:xaxis][:set_visible](false)
        ax[:set_ylim](-<span class="fl">0.1</span>,<span class="fl">1.1</span>)
        ax[:xaxis][:set_major_locator]=matplotlib[:ticker][:MultipleLocator](<span class="fl">1</span>)
        ax[:yaxis][:set_major_locator]=matplotlib[:ticker][:MultipleLocator](<span class="fl">1</span>)
    <span class="kw">end</span>
<span class="kw">end</span>
fig[:canvas][:draw]()</code></pre></div>
</div>
<div id="splines-show-some-basis-functions-1" class="slide section level1">
<h1>Splines: Show some Basis Functions</h1>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">
<img src="figs/cubic-bspline.png" alt="Cubic Spline Basis of degree 3" />
</div>
<ul>
<li>Notice that placing each of those panels on top of each other generates a sparse matrix!</li>
</ul>
</div>
<div id="b-splines-definition" class="slide section level1">
<h1>B-Splines: Definition</h1>
<ul>
<li>We mostly use Basis Splines, or <strong>B-Splines</strong>.</li>
<li>Here is a recursive definition of a B-Spline (and what is used in <code>ApproXD</code>):</li>
<li>Denote the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>-th basis function of degree <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> with knot vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle><annotation encoding="application/x-tex">\mathbf{z}</annotation></semantics></math> at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>B</mi><mi>j</mi><mrow><mi>k</mi><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">B_j^{k,\mathbf{z}} (x)</annotation></semantics></math></li>
<li>Again, there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>k</mi><mo>+</mo><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n = k + p - 1</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>'s (where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math><code>= length(z)</code>)</li>
<li>We can define <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>B</mi><mi>j</mi><mrow><mi>k</mi><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">B_j^{k,\mathbf{z}} (x)</annotation></semantics></math> recursively like this: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>B</mi><mi>j</mi><mrow><mi>k</mi><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi></mrow></msub></mrow><mrow><msub><mi>z</mi><mi>j</mi></msub><mo>−</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi></mrow></msub></mrow></mfrac><msubsup><mi>B</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mfrac><mrow><msub><mi>z</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>x</mi></mrow><mrow><msub><mi>z</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>k</mi></mrow></msub></mrow></mfrac><msubsup><mi>B</mi><mi>j</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">  B_j^{k,\mathbf{z}} (x) = \frac{x-z_{j-k}}{z_j - z_{j-k}} B_{j-1}^{k-1,\mathbf{z}} (x)  + \frac{z_{j+1}-x}{z_{j+1} - z_{j+1-k}} B_{j}^{k-1,\mathbf{z}} (x), j=1,\dots,n</annotation></semantics></math></li>
</ul>
<div class="incremental">
<ul>
<li>The recursion starts with <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>B</mi><mi>j</mi><mrow><mn>0</mn><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mn>1</mn></mtd><mtd><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>z</mi><mi>j</mi></msub><mo>≤</mo><mi>x</mi><mo>&lt;</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mtext mathvariant="normal">otherwise.</mtext></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> B_j^{0,\mathbf{z}} (x) = \begin{cases}
    1 &amp; \text{if }z_j \leq x &lt;  z_{j+1}\\
    0 &amp; \text{otherwise.}
    \end{cases}
    </annotation></semantics></math></li>
<li>For this formulation to work, we need to extend the knot vector for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&lt;</mo><mn>1</mn><mo>,</mo><mi>j</mi><mo>&gt;</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">j&lt;1,j&gt;p</annotation></semantics></math>: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>j</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mi>a</mi></mtd><mtd><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>j</mi><mo>≤</mo><mn>1</mn></mtd></mtr><mtr><mtd><mi>b</mi></mtd><mtd><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>j</mi><mo>≥</mo><mi>p</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> z_j = \begin{cases}
    a &amp; \text{if }j \leq 1\\
    b &amp; \text{if }j \geq p
    \end{cases} </annotation></semantics></math></li>
<li>And we need to set the endpoints <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>B</mi><mn>0</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo>=</mo><msubsup><mi>B</mi><mi>n</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> B_0^{k-1,\mathbf{z}} = B_n^{k-1,\mathbf{z}} =0 </annotation></semantics></math></li>
<li>You may see that this gives rise to a triangular computation strategy, as pointed out <a href="http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/bspline-basis.html">here</a>.</li>
</ul>
</div>
</div>
<div id="b-splines-derivatives-and-integrals" class="slide section level1">
<h1>B-Splines: Derivatives and Integrals</h1>
<ul>
<li>This is another very nice thing about B-Splines.</li>
<li>The derivative wrt to it's argument <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><msubsup><mi>B</mi><mi>j</mi><mrow><mi>k</mi><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mfrac><mi>k</mi><mrow><msub><mi>z</mi><mi>j</mi></msub><mo>−</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi></mrow></msub></mrow></mfrac><msubsup><mi>B</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mfrac><mi>k</mi><mrow><msub><mi>z</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>k</mi></mrow></msub></mrow></mfrac><msubsup><mi>B</mi><mi>j</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex"> \frac{d B_j^{k,\mathbf{z}} (x)}{dx} = \frac{k}{z_j - z_{j-k}} B_{j-1}^{k-1,\mathbf{z}} (x)  + \frac{k}{z_{j+1} - z_{j+1-k}} B_{j}^{k-1,\mathbf{z}} (x), j=1,\dots,n</annotation></semantics></math></li>
<li>Similarly, the Integral is just the sum over the basis functions: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>x</mi></msubsup><msubsup><mi>B</mi><mi>j</mi><mrow><mi>k</mi><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi><mi>y</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><mi>n</mi></munderover><mfrac><mrow><msub><mi>z</mi><mi>i</mi></msub><mo>−</mo><msub><mi>z</mi><mrow><mi>i</mi><mo>−</mo><mi>k</mi></mrow></msub></mrow><mi>k</mi></mfrac><msubsup><mi>B</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="bold"><mi>𝐳</mi></mstyle></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \int_a^x B_j^{k,\mathbf{z}} (y) dy = \sum_{i=j}^n \frac{z_i - z_{i-k}}{k} B_{i+1}^{k+1,\mathbf{z}} (x)  </annotation></semantics></math></li>
</ul>
</div>
<div id="linear-b-spline-a-useful-special-case" class="slide section level1">
<h1>Linear B-Spline: A useful special case</h1>
<ul>
<li>This is <em>connecting the dots with a straight line</em></li>
<li>This may incur some approximation error if the underlying function is very curved between the dots.</li>
<li>However, it has some benefits:
<ul>
<li>it is shape-preserving,</li>
<li>it is fast,</li>
<li>it is easy to build.</li>
</ul></li>
<li>For a linear spline with evenly spaced breakpoints, this becomes almost trivial.
<ul>
<li>Let's define <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mfrac><mrow><mi>b</mi><mo>−</mo><mi>a</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">h = \frac{b-a}{n-1}</annotation></semantics></math> as the distance between breakpoints.</li>
<li>Our basis function becomes very simple, giving us a measure of how far <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is from the next knot: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mn>1</mn><mo>−</mo><mfrac><mrow><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo>−</mo><msub><mi>z</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">|</mo></mrow><mi>h</mi></mfrac></mtd><mtd><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo>−</mo><msub><mi>z</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">|</mo><mo>≤</mo><mi>h</mi></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mtext mathvariant="normal">otherwise</mtext></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> \phi_j (x) = \begin{cases}
    1 - \frac{|x-z_j|}{h} &amp; \text{if } |x-z_j| \leq h \\
    0                    &amp; \text{otherwise}
    \end{cases} </annotation></semantics></math></li>
<li>Notice that each interior basis function (i.e. not 0 and not <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>) has witdth <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>h</mi></mrow><annotation encoding="application/x-tex">2h</annotation></semantics></math>.</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia">using ApproXD
bs = BSpline(<span class="fl">9</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">1</span>) <span class="co">#9 knots, degree 1 in [0,1]</span>
<span class="co"># how many basis functions? (go back 1 slide.)</span>
<span class="co"># getNumCoefs(bs)</span>
B = full(getBasis(collect(linspace(<span class="fl">0</span>,<span class="fl">1.0</span>,<span class="fl">500</span>)),bs))
<span class="co"># setup the plot</span>
fig,axes = subplots(<span class="fl">3</span>,<span class="fl">3</span>,figsize=(<span class="fl">10</span>,<span class="fl">5</span>))
<span class="kw">for</span> i <span class="kw">in</span> <span class="fl">1</span>:<span class="fl">3</span>
    <span class="kw">for</span> j <span class="kw">in</span> <span class="fl">1</span>:<span class="fl">3</span>
        ax = axes[j,i]
        count = i+(j-<span class="fl">1</span>)*<span class="fl">3</span>
        ax[:plot](B[:,count])
        ax[:grid]()
        ax[:set_title](<span class="st">&quot;Basis $(count-1)&quot;</span>)
        ax[:xaxis][:set_visible](false)
        ax[:set_ylim](-<span class="fl">0.1</span>,<span class="fl">1.1</span>)
        ax[:xaxis][:set_major_locator]=matplotlib[:ticker][:MultipleLocator](<span class="fl">1</span>)
        ax[:yaxis][:set_major_locator]=matplotlib[:ticker][:MultipleLocator](<span class="fl">1</span>)
    <span class="kw">end</span>
<span class="kw">end</span>
fig[:canvas][:draw]()</code></pre></div>
</div>
<div id="splines-linear-spline-plot" class="slide section level1">
<h1>Splines: Linear Spline Plot</h1>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">
<img src="figs/linear-bspline.png" alt="Spline Basis of degree 1" />
</div>
</div>
<div id="linear-b-spline-evaluation" class="slide section level1">
<h1>Linear B-Spline: Evaluation</h1>
<ul>
<li>In order to evaluate the linear interpolator, we need to know only one thing: Which knot span is active, i.e. what is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math> s.t. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>z</mi><mi>j</mi></msub><mo>,</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x\in [z_j, z_{j+1}]</annotation></semantics></math>?</li>
<li>This is a classic problem in computer science. Binary search.</li>
<li><code>julia</code> implements <a href="http://docs.julialang.org/en/release-0.4/stdlib/sort/#Base.searchsortedlast"><code>searchsortedlast</code></a>.</li>
<li>Once we know <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>, it's easy to get the interpolated value as <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><msub><mi>z</mi><mi>j</mi></msub></mrow><mi>h</mi></mfrac><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>z</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mfrac><mrow><msub><mi>z</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>x</mi></mrow><mi>h</mi></mfrac><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>z</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \hat{f}(x) = \frac{x-z_j}{h}  f(z_{j+1}) + \frac{z_{j+1}-x}{h}  f(z_{j}) </annotation></semantics></math></li>
</ul>
</div>
<div id="the-importance-of-knot-placement" class="slide section level1">
<h1>The Importance of Knot Placement</h1>
<ul>
<li>We just talked about <em>equally spaced knots</em>. This is just a special case.</li>
<li>B-Splines give us the flexibility to place the knots where we want.</li>
<li>Contrary to Polynomial interpolations (where we cannot choose the evaluation nodes), this is very helpful in cases where we know that a function is very curved in a particular region.</li>
<li>Canonical Example: Runge's function: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>+</mo><mn>25</mn><msup><mi>x</mi><mn>2</mn></msup><msup><mo stretchy="false" form="postfix">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">f(x) = (1+25x^2)^{-1}</annotation></semantics></math>.</li>
<li>Also: If you know that your function has a kink (i.e. a discontinuous first derivative) at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>x</mi><mo accent="true">^</mo></mover><annotation encoding="application/x-tex">\hat{x}</annotation></semantics></math>, then you can stack breakpoints on top of each other <em>at</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>x</mi><mo accent="true">^</mo></mover><annotation encoding="application/x-tex">\hat{x}</annotation></semantics></math></li>
</ul>
</div>
<div id="b-spline-approximation-with-interpolations.jl" class="slide section level1">
<h1>B-Spline Approximation with <a href="https://github.com/tlycken/Interpolations.jl"><code>Interpolations.jl</code></a></h1>
<ul>
<li>Let's go the readme page and give it a look!</li>
</ul>
</div>
<div id="the-compecon-toolbox-of-miranda-and-fackler" class="slide section level1">
<h1>The CompEcon Toolbox of Miranda and Fackler</h1>
<ul>
<li><a href="https://github.com/spencerlyon2/CompEcon.jl">CompEcon.jl</a></li>
</ul>
</div>
<div id="mulitidimensional-approximation" class="slide section level1">
<h1>Mulitidimensional Approximation</h1>
<ul>
<li>Up to now, everything we did was in one dimesion.</li>
<li>Economic problems <em>often</em> have more dimension than that.
<ul>
<li>The number of state variables in your value functions are the number of dimensions.</li>
</ul></li>
<li>We can readily extend what we learned into more dimensions.</li>
<li>However, we will quickly run into feasibility problems: hello <em>curse of dimensionality</em>.</li>
</ul>
</div>
<div id="tensor-product-of-univariate-basis-functions-product-rule" class="slide section level1">
<h1>Tensor Product of univariate Basis Functions: Product Rule</h1>
<ul>
<li>One possibility is to approximate e.g. the 2D function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math> by <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>c</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><msubsup><mi>ϕ</mi><mi>i</mi><mi>x</mi></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><msubsup><mi>ϕ</mi><mi>j</mi><mi>y</mi></msubsup><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \hat{f}(x,y) = \sum_{i=1}^n \sum_{j=1}^m c_{i,j} \phi_i^x(x) \phi_j^y(y)  </annotation></semantics></math>
<ul>
<li>here <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ϕ</mi><mi>i</mi><mi>x</mi></msubsup><annotation encoding="application/x-tex">\phi_i^x</annotation></semantics></math> is the basis function in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> space,</li>
<li>you can see that the coefficient vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">c_{i,j}</annotation></semantics></math> is indexed in two dimensions now.</li>
<li>Notice that our initial notation was general enough to encompass this case, as we defined the basis functions as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>d</mi></msup><mo accent="false">↦</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbb{R}^d \mapsto \mathbb{R}</annotation></semantics></math>. So with the product rule, this mapping is just given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ϕ</mi><mi>i</mi><mi>x</mi></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><msubsup><mi>ϕ</mi><mi>j</mi><mi>y</mi></msubsup><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi_i^x(x) \phi_j^y(y)</annotation></semantics></math>.</li>
</ul></li>
<li>This formulation requires that we take the product of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ϕ</mi><mi>i</mi><mi>x</mi></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msubsup><mi>ϕ</mi><mi>j</mi><mi>y</mi></msubsup><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi_i^x(x), \phi_j^y(y)</annotation></semantics></math> at <em>all</em> combinations of their indices, as is clear from the summations.</li>
<li>This is equivalent to the tensor product between <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ϕ</mi><mi>i</mi><mi>x</mi></msubsup><annotation encoding="application/x-tex">\phi_i^x</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ϕ</mi><mi>j</mi><mi>y</mi></msubsup><annotation encoding="application/x-tex">\phi_j^y</annotation></semantics></math>.</li>
</ul>
<h2 id="compute-c">Computing Coefficients from Tensor Product Spaces</h2>
<ul>
<li>Extending this into <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math> dimensions, where in each dim <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>i</mi></msub><annotation encoding="application/x-tex">n_i</annotation></semantics></math> basis functions, we get <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mi>D</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mn>1</mn></msub></munderover><munderover><mo>∑</mo><mrow><msub><mi>i</mi><mn>2</mn></msub><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mn>2</mn></msub></munderover><mi>…</mi><munderover><mo>∑</mo><mrow><msub><mi>i</mi><mi>D</mi></msub><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>D</mi></msub></munderover><msub><mi>c</mi><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>i</mi><mi>D</mi></msub></mrow></msub><msub><mi>ϕ</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><msub><mi>ϕ</mi><msub><mi>i</mi><mn>2</mn></msub></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mi>…</mi><msub><mi>ϕ</mi><msub><mi>i</mi><mi>D</mi></msub></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>D</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \hat{f}(x_1,x_2,\dots,x_D) = \sum_{i_1=1}^{n_1} \sum_{i_2=1}^{n_2} \dots  \sum_{i_D=1}^{n_D} c_{i_1,i_2,\dots,i_D} \phi_{i_1}(x_1) \phi_{i_2}(x_2) \dots \phi_{i_D}(x_D)  </annotation></semantics></math></li>
<li>In Vector notation <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mi>D</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>ϕ</mi><mi>D</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mi>D</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><msub><mi>ϕ</mi><mrow><mi>D</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mrow><mi>D</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mi>…</mi><mo>⊗</mo><msub><mi>ϕ</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">]</mo></mrow><mi>c</mi></mrow><annotation encoding="application/x-tex"> 
\hat{f}(x_1,x_2,\dots,x_D) =  \left[ \phi_{D}(x_D) \otimes \phi_{D-1}(x_{D-1})  \otimes \dots  \otimes  \phi_{1}(x_1) \right]  c </annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> is is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msubsup><mi>Π</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></msubsup><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n=\Pi_{i=1}^D n_i</annotation></semantics></math> column vector</li>
<li>The solution is the interpolation equation as before, <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>Φ</mi><mi>c</mi><mo>=</mo></mtd><mtd columnalign="left"><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mi>Φ</mi><mo>=</mo></mtd><mtd columnalign="left"><msub><mi>Φ</mi><mi>D</mi></msub><mo>⊗</mo><msub><mi>Φ</mi><mrow><mi>D</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⊗</mo><mi>…</mi><mo>⊗</mo><msub><mi>Φ</mi><mn>1</mn></msub></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{align}\Phi c =&amp; y \\
                \Phi   =&amp; \Phi_D \otimes \Phi_{D-1} \otimes \dots \otimes \Phi_{1} \end{align} </annotation></semantics></math></li>
</ul>
</div>
<div id="the-problem-with-tensor-product-of-univariate-basis-functions" class="slide section level1">
<h1>The Problem with Tensor Product of univariate Basis Functions</h1>
<ul>
<li>What's the problem?</li>
<li>Well, solving <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Φ</mi><mi>c</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\Phi c = y</annotation></semantics></math> is hard.</li>
<li>If we have as many evaluation points as basis functions in each dimension, i.e. if each single <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Φ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\Phi_i</annotation></semantics></math> is a square matrix, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math> is of size (n,n).</li>
<li>Inverting this is <em>extremely</em> hard even for moderately sized problems.</li>
<li>Sometimes it's not even possible to allocate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math> in memory.</li>
<li>Here it's important to remember the sparsity structure of a spline basis function.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia">using PyPlot
fig = figure()
ax = axes()
ax[:imshow](B)  <span class="co"># B was the BSpline basis from before</span>
ax[:set_aspect](<span class="st">&quot;auto&quot;</span>)
fig[:canvas][:draw]()</code></pre></div>
</div>
<div id="sparseness-of-b-spline-basis" class="slide section level1">
<h1>Sparseness of B-Spline Basis</h1>
<div class="center" style="width: auto; margin-left: auto; margin-right: auto;">
<img src="figs/spline-basis-sparse.png" alt="BSpline basis functions are sparse." />
</div>
<ul>
<li>Blue is zero.</li>
<li>the y axis lists 500 equispaced points in [0,1]</li>
<li>the x axis shows the value of all basis functions
<ul>
<li>i.e. each row is all basis functions evaluated at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>i</mi></msub><annotation encoding="application/x-tex">x_i</annotation></semantics></math></li>
</ul></li>
<li>This is a cubic spline basis. at most <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k+1=3</annotation></semantics></math> basis are non-zero for any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>.</li>
</ul>
</div>
<div id="using-sparsity-of-splines" class="slide section level1">
<h1>Using Sparsity of Splines</h1>
<ul>
<li>It may be better to store the splines in sparse format.</li>
<li>Look at object <code>B</code> by typing <code>B</code> and <code>typeof(B)</code></li>
<li>There are sparse system solvers available.</li>
<li>Creating and storing the inverse of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math> destroys the sparsity structure (inverse of a sparse matrix is not sparse), and may not be a good idea.</li>
<li>Look back at <a href="#compute-c">Computing coefficients form the tensor product</a></li>
<li>We only have to sum over the non-zero entries! Every other operation is pure cost.</li>
<li><p>This is implemented in <code>ApproXD.jl</code> for example via</p>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia"><span class="kw">function</span> evalTensor2{T}(mat1::SparseMatrixCSC{T,<span class="dt">Int64</span>},
                        mat2::SparseMatrixCSC{T,<span class="dt">Int64</span>},
                        c::<span class="dt">Vector</span>{T})</code></pre></div></li>
</ul>
</div>
<div id="high-dimensional-functions-introducing-the-smolyak-grid" class="slide section level1">
<h1>High Dimensional Functions: Introducing the Smolyak Grid</h1>
<ul>
<li>This is a modification of the Tensor product rule.</li>
<li>It elemininates points from the full tensor product according to their <em>importance</em> for the quality of approximation.</li>
<li>The user controls this quality parameter, thereby increasing/decreasing the size of the grid.</li>
<li><span class="citation">(Kenneth L Judd et al. 2014)</span> is a complete technical reference for this method.</li>
<li><span class="citation">(Maliar and Maliar 2013)</span> chapter 4 is very good overview of this topic, and the basis of this part of the lecture.</li>
</ul>
</div>
<div id="the-smolyak-grid-in-2-dimensions" class="slide section level1">
<h1>The Smolyak Grid in 2 Dimensions</h1>
<ul>
<li>Approximation level <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle></mrow><annotation encoding="application/x-tex">\mu \in \mathbb{N}</annotation></semantics></math> governs the quality of the approximation.</li>
<li>Start with a unidimensional grid of points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mo>−</mo><mn>1</mn><mo>,</mo><mfrac><mrow><mo>−</mo><mn>1</mn></mrow><msqrt><mn>2</mn></msqrt></mfrac><mo>,</mo><mn>0</mn><mo>,</mo><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex"> x = \left\{-1,\frac{-1}{\sqrt{2}},0,\frac{1}{\sqrt{2}},1\right\} </annotation></semantics></math> which are 5 Chebyshev nodes (it's not important that those are Chebyshev nodes, any grid will work).</li>
<li>A 2D tensor product <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊗</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x\otimes x</annotation></semantics></math> gives 25 grid points <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊗</mo><mi>x</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mo stretchy="false" form="prefix">(</mo><mo>−</mo><mn>1</mn><mo>,</mo><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mo>−</mo><mn>1</mn><mo>,</mo><mfrac><mrow><mo>−</mo><mn>1</mn></mrow><msqrt><mn>2</mn></msqrt></mfrac><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>…</mi><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex"> x\otimes x=\left\{(-1,-1),(-1,\frac{-1}{\sqrt{2}}),\dots,(1,1)\right\} </annotation></semantics></math></li>
<li>The Smolyak method proceeds differently.</li>
<li>We construct three nested sets: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="left"><mi>i</mi><mo>=</mo><mn>1</mn><mo>:</mo><msub><mi>S</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mi>i</mi><mo>=</mo><mn>2</mn><mo>:</mo><msub><mi>S</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mi>i</mi><mo>=</mo><mn>3</mn><mo>:</mo><msub><mi>S</mi><mn>3</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mo>−</mo><mn>1</mn><mo>,</mo><mfrac><mrow><mo>−</mo><mn>1</mn></mrow><msqrt><mn>2</mn></msqrt></mfrac><mo>,</mo><mn>0</mn><mo>,</mo><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{array}{l}
    i=1 : S_1 = \{0\} \\
    i=2 : S_2 = \{0,-1,1\} \\
    i=3 : S_3 = \left\{-1,\frac{-1}{\sqrt{2}},0,\frac{1}{\sqrt{2}},1\right\}  \end{array} </annotation></semantics></math></li>
<li>Then, we construct all possible 2D tensor products using elements from these nested sets in a table (next slide).</li>
<li>Finally, we select only those elements of the table, that satisfy the Smolyak rule: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>+</mo><msub><mi>i</mi><mn>2</mn></msub><mo>≤</mo><mi>d</mi><mo>+</mo><mi>μ</mi></mrow><annotation encoding="application/x-tex"> i_1 + i_2 \leq d + \mu </annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">i_1,i_2</annotation></semantics></math> are column and row index, respectively, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>,</mo><mi>μ</mi></mrow><annotation encoding="application/x-tex">d,\mu</annotation></semantics></math> are the number of dimensions and the quality of approximation.</li>
</ul>
</div>
<div id="the-smolyak-grid-in-2d-tensor-table" class="slide section level1">
<h1>The Smolyak Grid in 2D: Tensor Table</h1>
<div class="figure">
<img src="figs/smolyak-tensortab.png" alt="(Maliar and Maliar 2013) table 3: All Tensor Products" />
<p class="caption"><span class="citation">(Maliar and Maliar 2013)</span> table 3: All Tensor Products</p>
</div>
<h2 id="selecting-elements">Selecting Elements</h2>
<ul>
<li>Denote the Smolyak grid for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math> dimensions at level <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="script"><mi>ℋ</mi></mstyle><mrow><mi>d</mi><mo>,</mo><mi>μ</mi></mrow></msup><annotation encoding="application/x-tex">\mathcal{H}^{d,\mu}</annotation></semantics></math>.</li>
<li>if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mu=0</annotation></semantics></math> we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>+</mo><msub><mi>i</mi><mn>2</mn></msub><mo>≤</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i_1+i_2\leq 2</annotation></semantics></math>. Only one point satisfies this, and <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="script"><mi>ℋ</mi></mstyle><mrow><mn>2</mn><mo>,</mo><mn>0</mn></mrow></msup><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex"> \mathcal{H}^{2,0} = \{(0,0)\} </annotation></semantics></math></li>
<li>if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mu=1</annotation></semantics></math> we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>+</mo><msub><mi>i</mi><mn>2</mn></msub><mo>≤</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">i_1+i_2\leq 3</annotation></semantics></math>. Three cases satisfy this:
<ol style="list-style-type: decimal">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>=</mo><mn>1</mn><mo accent="false">→</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">i_1 = 1, i_2=1 \rightarrow (0,0)</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>=</mo><mn>2</mn><mo accent="false">→</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">i_1 = 1, i_2=2 \rightarrow (0,0),(0,-1),(0,1)</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mn>2</mn><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>=</mo><mn>1</mn><mo accent="false">→</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">i_1 = 2, i_2=1 \rightarrow (0,0),(-1,0),(1,0)</annotation></semantics></math></li>
</ol>
<ul>
<li>Therefore, the unique elements from the union of all of those is <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="script"><mi>ℋ</mi></mstyle><mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msup><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex"> \mathcal{H}^{2,1} = \{(0,0),(-1,0),(1,0),(0,-1),(0,1)\} </annotation></semantics></math></li>
</ul></li>
<li>if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\mu=2</annotation></semantics></math> we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>+</mo><msub><mi>i</mi><mn>2</mn></msub><mo>≤</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">i_1+i_2\leq 4</annotation></semantics></math>. Six cases satisfy this:
<ol style="list-style-type: decimal">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i_1 = 1, i_2=1</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i_1 = 1, i_2=2</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mn>2</mn><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i_1 = 2, i_2=1</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">i_1 = 1, i_2=3</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mn>2</mn><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i_1 = 2, i_2=2</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mn>3</mn><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i_1 = 3, i_2=1</annotation></semantics></math></li>
</ol>
<ul>
<li>Therefore, the unique elements from the union of all of those is <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mstyle mathvariant="script"><mi>ℋ</mi></mstyle><mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mo stretchy="false" form="prefix">(</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mo>−</mo><mn>1</mn><mo>,</mo><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mo>−</mo><mn>1</mn></mrow><msqrt><mn>2</mn></msqrt></mfrac><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mfrac><mrow><mo>−</mo><mn>1</mn></mrow><msqrt><mn>2</mn></msqrt></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex"> \mathcal{H}^{2,2} = \left\{(-1,1),(0,1),(1,1),(-1,0),(0,0),(1,0),(-1,-1),(0,-1),(1,-1),\left(\frac{-1}{\sqrt{2}},0\right),\left(\frac{1}{\sqrt{2}},0\right),\left(0,\frac{-1}{\sqrt{2}}\right),\left(0,\frac{1}{\sqrt{2}}\right)\right\} </annotation></semantics></math></li>
</ul></li>
<li>Note that those elements are on the diagonal from top left to bottom right expanding through all the tensor products on table 3.</li>
</ul>
</div>
<div id="size-of-smolyak-grids" class="slide section level1">
<h1>Size of Smolyak Grids</h1>
<ul>
<li>The Smolyak grid grows much slower (at order <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math> to a power of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>) than the Tensor grid (exponential growth)</li>
</ul>
<div class="figure">
<img src="figs/smolyak-vs-tensor.png" alt="(Maliar and Maliar 2013) figure 2: Tensor vs Smolyak in 2D" />
<p class="caption"><span class="citation">(Maliar and Maliar 2013)</span> figure 2: Tensor vs Smolyak in 2D</p>
</div>
<div class="figure">
<img src="figs/smolyak-tensor-points.png" alt="(Maliar and Maliar 2013) figure 4: Tensor vs Smolyak in 2D, number of grid points" />
<p class="caption"><span class="citation">(Maliar and Maliar 2013)</span> figure 4: Tensor vs Smolyak in 2D, number of grid points</p>
</div>
</div>
<div id="smolyak-polynomials" class="slide section level1">
<h1>Smolyak Polynomials</h1>
<ul>
<li>Corresponding to the construction of grid points, there is the Smolyak way of constructing polynomials.</li>
<li>This works exactly as before. We start with a one-dimensional set of basis functions (again Chebyshev here, again irrelevant): <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>x</mi><mo>,</mo><mn>2</mn><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn><mo>,</mo><mn>4</mn><msup><mi>x</mi><mn>3</mn></msup><mo>−</mo><mn>3</mn><mi>x</mi><mo>,</mo><mn>8</mn><msup><mi>x</mi><mn>4</mn></msup><mo>−</mo><mn>8</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">}</mo></mrow><annotation encoding="application/x-tex"> \left\{1,x,2x^2-1,4x^3-3x,8x^4-8x^2+1\right\} </annotation></semantics></math></li>
<li>Three nested sets: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="left"><mi>i</mi><mo>=</mo><mn>1</mn><mo>:</mo><msub><mi>S</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mi>i</mi><mo>=</mo><mn>2</mn><mo>:</mo><msub><mi>S</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>x</mi><mo>,</mo><mn>2</mn><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mi>i</mi><mo>=</mo><mn>3</mn><mo>:</mo><msub><mi>S</mi><mn>3</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>x</mi><mo>,</mo><mn>2</mn><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn><mo>,</mo><mn>4</mn><msup><mi>x</mi><mn>3</mn></msup><mo>−</mo><mn>3</mn><mi>x</mi><mo>,</mo><mn>8</mn><msup><mi>x</mi><mn>4</mn></msup><mo>−</mo><mn>8</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{array}{l}
    i=1 : S_1 = \{1\} \\
    i=2 : S_2 = \{1,x,2x^2-1\} \\
    i=3 : S_3 = \left\{1,x,2x^2-1,4x^3-3x,8x^4-8x^2+1\right\}  \end{array} </annotation></semantics></math></li>
<li>Denoting <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="script"><mi>𝒫</mi></mstyle><mrow><mi>d</mi><mo>,</mo><mi>μ</mi></mrow></msup><annotation encoding="application/x-tex">\mathcal{P}^{d,\mu}</annotation></semantics></math> the Smolyak polynomial, we follow exactly the same steps as for the grids to select elements of the full tensor product table 5:</li>
</ul>
<div class="figure">
<img src="figs/smolyak-polynomial.png" alt="(Maliar and Maliar 2013) figure 5: All Smolyak Polynomials in 2D" />
<p class="caption"><span class="citation">(Maliar and Maliar 2013)</span> figure 5: All Smolyak Polynomials in 2D</p>
</div>
</div>
<div id="smolyak-interpolation" class="slide section level1">
<h1>Smolyak Interpolation</h1>
<p>This proceeds as in the previouses cases:</p>
<ol style="list-style-type: decimal">
<li>Evaluate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> at all grid points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="script"><mi>ℋ</mi></mstyle><mrow><mi>d</mi><mo>,</mo><mi>μ</mi></mrow></msup><annotation encoding="application/x-tex">\mathcal{H}^{d,\mu}</annotation></semantics></math>.</li>
<li>Evaluate the set of basis functions given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="script"><mi>𝒫</mi></mstyle><mrow><mi>d</mi><mo>,</mo><mi>μ</mi></mrow></msup><annotation encoding="application/x-tex">\mathcal{P}^{d,\mu}</annotation></semantics></math>f$ at all grid points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="script"><mi>ℋ</mi></mstyle><mrow><mi>d</mi><mo>,</mo><mi>μ</mi></mrow></msup><annotation encoding="application/x-tex">\mathcal{H}^{d,\mu}</annotation></semantics></math>.</li>
<li>Solve for the interpolating coefficients by inverting the Basis function matrix.</li>
</ol>
<h2 id="extensions">Extensions</h2>
<ul>
<li>There is a lot of redundancy in computing the grids the way we did it.</li>
<li>More sophisticated approaches take care not to compute repeated elements.</li>
</ul>
</div>
<div id="smolyak-grids-in-julia" class="slide section level1">
<h1>Smolyak Grids in Julia</h1>
<ul>
<li>There are at least 2 julia packages that implement this idea:
<ul>
<li><a href="https://github.com/EconForge/Smolyak" class="uri">https://github.com/EconForge/Smolyak</a></li>
<li><a href="https://github.com/alancrawford/Smolyak" class="uri">https://github.com/alancrawford/Smolyak</a></li>
</ul></li>
</ul>
</div>
<div id="using-alancrawfordsmolyak" class="slide section level1">
<h1>Using <code>alancrawford/Smolyak</code></h1>
<p>From the unit tests of that package:</p>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia">    Pkg.clone(<span class="st">&quot;https://github.com/alancrawford/Smolyak.git&quot;</span>)

    <span class="co"># here is the true function</span>
    <span class="co"># in a real world application, evaluating this is the biggest cost</span>
    <span class="co"># we would like to evaluate only a few times.</span>

    slopes = rand(<span class="fl">4</span>)    
    truefun(x) = <span class="fl">1.1</span> + slopes[<span class="fl">1</span>]*x[<span class="fl">1</span>] - slopes[<span class="fl">2</span>]*x[<span class="fl">2</span>]^<span class="fl">2</span> + (slopes[<span class="fl">3</span>]*x[<span class="fl">3</span>])^<span class="fl">3</span> * slopes[<span class="fl">4</span>] * x[<span class="fl">4</span>]

    <span class="co"># choose approx level in each dim</span>
    mu = [<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">2</span>,<span class="fl">1</span>]
    D = length(mu)
    lb = -<span class="fl">2</span>*ones(length(mu))
    ub = <span class="fl">12</span>*ones(length(mu))
    sg = SmolyakGrid(mu,lb,ub)
    sb = SmolyakBasis(sg)
    makeBasis!(sb)
    sp = SmolyakPoly(sb)

    <span class="kw">for</span> i <span class="kw">in</span> <span class="fl">1</span>:sb.NumPts
        sp.Value[i] = truefun(sg.xGrid[i])  <span class="co"># Assign true fvals to poly</span>
    <span class="kw">end</span>
    make_pinvBFt!(sp,sb)        
    Smolyak.MakeCoef!(sp)       

    <span class="co"># make basis on random point</span>
    NumObs = <span class="fl">50</span>
    X = <span class="dt">Vector</span>{<span class="dt">Float64</span>}[ <span class="dt">Float64</span>[lb[d]+( ub[d]- lb[d])*rand() <span class="kw">for</span> d <span class="kw">in</span> <span class="fl">1</span>:D] <span class="kw">for</span> i <span class="kw">in</span> <span class="fl">1</span>:NumObs]
    sbX = SmolyakBasis(X,mu,lb,ub,<span class="fl">0</span>,<span class="fl">0</span>)
    makeBasis!(sbX)
    spX = SmolyakPoly(sbX)
    copy!(spX.Coef,sp.Coef)   <span class="co"># assign precomputed coefs</span>
    ynew = makeValue!(spX,sbX) <span class="co"># Interpolated Values</span>
    valsnew = [truefun(i) <span class="kw">for</span> i <span class="kw">in</span> X]
    using PyPlot
    scatter(ynew,valsnew)
    ylabel(<span class="st">&quot;truth&quot;</span>)
    xlabel(<span class="st">&quot;approx&quot;</span>)
    grid()</code></pre></div>
</div>
<div class="slide section level1">

<h2 id="bibliography">Bibliography</h2>
<ul>
<li><span class="citation">(Fackler and Miranda 2004)</span> is the main reference for this lecture.</li>
<li><span class="citation">(Kenneth L. Judd 1998)</span> is the classic reference. A bit more difficult.</li>
<li><span class="citation">(Aruoba and Fernandez-Villaverde 2014)</span> gives an overview over computing languages widely used in Economics.</li>
</ul>
</div>
<div id="references" class="slide section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-jesus-computing">
<p>Aruoba, S. B., &amp; Fernandez-Villaverde, J. (2014). <em>A comparison of programming languages in economics</em>. National Bureau of Economic Research. <a href="http://economics.sas.upenn.edu/~jesusfv/comparison_languages.pdf" class="uri">http://economics.sas.upenn.edu/~jesusfv/comparison_languages.pdf</a></p>
</div>
<div id="ref-deboor">
<p>De Boor, C. (1978). A practical guide to splines. <em>Mathematics of Computation</em>.</p>
</div>
<div id="ref-fackler-miranda">
<p>Fackler, Paul L, &amp; Miranda, M. J. (2004). <em>Applied computational economics and finance</em>. MIT press.</p>
</div>
<div id="ref-judd-book">
<p>Judd, K. L. (1998). <em>Numerical methods in economics</em>. The MIT Press.</p>
</div>
<div id="ref-jmmv">
<p>Judd, K. L., Maliar, L., Maliar, S., &amp; Valero, R. (2014). Smolyak method for solving dynamic economic models: Lagrange interpolation, anisotropic grid and adaptive domain. <em>Journal of Economic Dynamics and Control</em>, <em>44</em>, 92–123.</p>
</div>
<div id="ref-maliar-maliar">
<p>Maliar, L., &amp; Maliar, S. (2013). Numerical methods for large scale dynamic economic models. <em>Handbook of Computational Economics</em>, <em>3</em>, 325. doi:<a href="https://doi.org/http://dx.doi.org/10.1016/B978-0-444-52980-0.00007-4">http://dx.doi.org/10.1016/B978-0-444-52980-0.00007-4</a></p>
</div>
</div>
</div>
</body>
</html>
